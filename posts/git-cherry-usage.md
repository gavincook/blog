
小红最近参与的项目，发布频次比较高。经常是边有功能开发，边发布。为了保证发布特定的功能特性，且不会被正在进行的开发影响，每次准备上线时就会从master分支切出一个新的发布分支，比如release/1.0.0。
这样就可以对发布分支进行发布前的验证，如果有BUG，也可以直接在发布分支上进行修复即可。与此同时，还能继续愉快地在master进行新特性的开发。

### 问题场景
有些改动是两个分支都需要提交。比如，在发布分支上修复的bug，此时也需要在master分支进行修复。分支情况如图：

难道同样的问题要在不同分支修复两次吗？
不，当然不用这么做。我们只需要将在发布分支修复问题的代码提交，应用到master分支。
`git cherry-pick {commit-sha}`这个命令就可以将指定sha的提交，应用到当前分支上。
没错，小红也是这么干的。小红执行了`git cherry-pick c3`:


然后小红就又干其他更重要的大事去了，忘记处理c5了，最后就导致c5就被遗弃在发布分支，没有应用到master分支。

当成功发布上线了，是需要将发布分支上的问题修复都应用到master分支上，以保证在发布分支上的改动会一直生效。
摆在小红面前的有两条路：
1. 直接使用`git merge`，进行分支合并
2. 对没有应用到master的提交，再使用`git cherry-pick`进行提交应用

很明显，第一个选项看起来，操作更简单呀。一个命令就搞定了，也不用像第二个选项那样还得去找哪些没有被应用到master上。
于是，发布成功后，小红就准备好了`git merge release/v1.0.0`，来，走你！
什么，有冲突？那就解决冲突，怎么，还有冲突？结果一个`git merge`执行只需一秒，但后续的冲突解决多得让小红头痛。

要不我们试试第二个选项？我们在回顾下小红这里的场景，是需要将发布分支上的问题修复都应用到master分支。
发布分支不是基于master分支的某个历史版本吗？发布分支的问题，那在master分支也是有问题的，对于这种提交，小红都是要将改动通过`git cherry-pick`应用到master上的。
那到现在是不是发布分支上的问题修复都应用到master分支呢？
由于都是小红人工进行`git cherry-pick`，还不是圣人的小红，且发布分支的问题修复紧急性也比较高，有时也会因为种种原因忘记操作`git cherry-pick`。
在最后分支“合并”的时候，小红只需要简单核查下是否改动都应用到master上了，或者处理少量的因为疏忽遗漏的改动。
提交可能会非常多，在两个分支上，一个个提交去比对这种事情是不可能干的，一辈子都不可能去干。

### 比对神器
那有什么工具或者操作可以解放小红生产力的吗？当然，`git cherry`（注意这里不是`cherry-pick`），就是这种场景的良药。

```bash
git cherry [-v] [<upstream> [<head> [<limit>]]]
```

主要用于比较<head>上的提交是否和<upstream>的相同，其中`-v`参数用于显示提交的描述。
会得到类似如下的输出：
```
- cccc000... commit C
+ bbbb000... commit B
- aaaa000... commit A
```
+表示，在<head>上并没有提交到<upstream>上，也就是commit B是一个被小红疏忽的提交，还没有被应用到upstream上。
-表示，在<head>上且已经通过cherry-pick应用到<upstream>上，也即commit A和commit C已经被小红兢兢业业地应用到了upstream上。

对于小红这里的场景，就可以使用如下命令去检查`release/1.0.0`的提交是否都应用到了`master`分支上。
```
git cherry -v master release/1.0.0
```
由于这里只关注没有被应用的提交，那我们再稍加修饰：
```
git cherry -v master release/1.0.0|grep +
```
这样，小红就可以从万千提交里，筛选出小红疏忽的提交。小红又多了不少时间可以愉快地玩耍了。